<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nritya AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: white;
            overflow-x: hidden;
        }

        /* Navigation */
        .nav {
            position: fixed;
            top: 0;
            width: 100%;
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(10px);
            z-index: 1000;
            padding: 15px 0;
            border-bottom: 1px solid rgba(233, 69, 96, 0.3);
        }

        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: #e94560;
        }

        .nav-links {
            display: flex;
            gap: 30px;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            transition: color 0.3s;
            cursor: pointer;
        }

        .nav-link:hover, .nav-link.active {
            color: #f27121;
        }

        /* Pages */
        .page {
            display: none;
            min-height: 100vh;
            padding: 80px 20px 20px;
        }

        .page.active {
            display: block;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Landing Page */
        .hero {
            text-align: center;
            padding: 100px 0;
        }

        .hero h1 {
            font-size: 4rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #e94560, #f27121);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 10px rgba(233, 69, 96, 0.5)); }
            to { filter: drop-shadow(0 0 20px rgba(242, 113, 33, 0.8)); }
        }

        .hero p {
            font-size: 1.2rem;
            margin-bottom: 40px;
            opacity: 0.9;
        }

        .cta-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(45deg, #e94560, #f27121);
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn.secondary {
            background: transparent;
            border: 2px solid #f27121;
        }

        /* Live Tracking Page */
        .tracking-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .video-section {
            background: rgba(30, 30, 60, 0.6);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        .video-container {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #video {
            width: 100%;
            height: auto;
            border-radius: 15px;
        }

        #poseCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .data-section {
            background: rgba(30, 30, 60, 0.6);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(242, 113, 33, 0.3);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat {
            text-align: center;
            padding: 10px;
            background: rgba(233, 69, 96, 0.1);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #f27121;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* Choreography Page */
        .choreo-container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-top: 20px;
        }

        .choreo-controls {
            background: rgba(30, 30, 60, 0.6);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        .choreo-canvas-container {
            background: rgba(30, 30, 60, 0.6);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(242, 113, 33, 0.3);
        }

        #choreoCanvas {
            width: 100%;
            height: 400px;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.3);
        }

        .dance-style {
            margin-bottom: 20px;
        }

        .dance-style label {
            display: block;
            margin-bottom: 10px;
            color: #f27121;
            font-weight: 600;
        }

        .dance-style select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(233, 69, 96, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .pose-list {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }

        .pose-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 5px;
            background: rgba(233, 69, 96, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .pose-item:hover {
            background: rgba(233, 69, 96, 0.2);
        }

        .pose-item.active {
            background: rgba(242, 113, 33, 0.3);
        }

        /* Gallery Page */
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .gallery-item {
            background: rgba(30, 30, 60, 0.6);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(233, 69, 96, 0.3);
            text-align: center;
        }

        .gallery-thumbnail {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 10px;
        }

        /* --- Virtual Dance Instructor Enhancements --- */
        #instructorSidebarInfo {
            margin-top: 22px;
            background: rgba(30,30,60,0.95);
            border-radius: 14px;
            padding: 18px 16px;
            color: #fff;
            font-size: 1.08em;
            box-shadow: 0 4px 24px 0 rgba(233,69,96,0.10);
            transition: box-shadow 0.3s;
        }
        #instructorSidebarInfo .feedback-panel {
            margin-top: 18px;
            background: rgba(233,69,96,0.13);
            border-radius: 10px;
            padding: 14px 10px;
            text-align: center;
            font-size: 1.15em;
            box-shadow: 0 2px 8px 0 rgba(242,113,33,0.08);
        }
        #instructorSidebarInfo .feedback-panel .emoji {
            font-size: 2.2em;
            vertical-align: middle;
            margin-left: 8px;
        }
        #instructorSidebarInfo .feedback-panel .sim {
            font-size: 1.25em;
            font-weight: bold;
            color: #f27121;
        }
        #instructorSidebarInfo .feedback-panel .timer {
            font-size: 1.08em;
            color: #e94560;
            margin-left: 10px;
        }
        #instructorSidebarInfo .move-meta {
            margin-bottom: 8px;
            font-size: 1.08em;
            color: #f27121;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        #instructorSidebarInfo .move-meta .move-style {
            color: #fff;
            font-weight: normal;
            font-size: 0.98em;
            margin-left: 8px;
        }
        #instructorSidebarInfo button {
            width: 100%;
            margin-top: 10px;
            font-size: 1.08em;
            padding: 12px 0;
        }
        @media (max-width: 900px) {
            #instructor .container > div {
                flex-direction: column !important;
            }
            #instructorSidebarInfo {
                margin-bottom: 24px;
            }
        }
        @media (max-width: 600px) {
            #instructorSidebarInfo, .choreo-controls {
                padding: 10px 4vw !important;
            }
            #instructorSidebarInfo .feedback-panel {
                padding: 10px 2vw;
            }
        }

        /* Animate move name */
        @keyframes fadeInMove {
            from { opacity: 0; transform: translateY(-10px);}
            to { opacity: 1; transform: translateY(0);}
        }
        #moveNameDisplay {
            animation: fadeInMove 0.7s;
            color: #f27121;
            font-size: 2.1em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }
        #moveStyleDisplay {
            color: #e94560;
            font-size: 1.08em;
            text-align: center;
            margin-bottom: 16px;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-container">
            <div class="logo" id="navHome" style="cursor:pointer;">Nritya AI</div>
            <div class="nav-links">
                <a href="#" class="nav-link active" data-page="home">Home</a>
                <a href="#" class="nav-link" data-page="tracking">Live Tracking</a>
                <a href="#" class="nav-link" data-page="choreography">Choreography</a>
                <a href="#" class="nav-link" data-page="gallery">Gallery</a>
                <a href="#" class="nav-link" data-page="instructor">Virtual Dance Instructor</a>
            </div>
        </div>
    </nav>

    <!-- Home Page -->
    <div class="page active" id="home">
        <div class="container">
            <div class="hero">
                <h1>Nritya AI</h1>
                <p>Professional Motion Capture & Dance Choreography Generation</p>
                <div class="cta-buttons">
                    <a href="#" class="btn" data-page="tracking">Start Live Tracking</a>
                    <a href="#" class="btn secondary" data-page="choreography">Generate Choreography</a>
                </div>
            </div>
            <div style="margin: 60px auto 0 auto; max-width: 800px; background: rgba(30,30,60,0.7); border-radius: 18px; padding: 32px 24px;">
                <h2 style="color:#f27121; text-align:center; margin-bottom:18px;">What is Nritya AI?</h2>
                <p style="font-size:1.15rem; line-height:1.7; text-align:center;">
                    <b>Nritya AI</b> is an AI-powered platform for dancers, choreographers, and learners.<br>
                    <span style="color:#e94560;">Capture your dance moves in real-time, generate creative choreography, and explore the beauty of Indian dance heritage.</span>
                </p>
                <div style="display:flex; flex-wrap:wrap; justify-content:center; gap:30px; margin-top:32px;">
                    <div style="flex:1 1 220px; min-width:220px; background:rgba(233,69,96,0.08); border-radius:12px; padding:18px;">
                        <h3 style="color:#f27121;">üé• Live Motion Tracking</h3>
                        <p style="font-size:1rem;">Track your dance poses using your webcam and get instant feedback on your movements.</p>
                    </div>
                    <div style="flex:1 1 220px; min-width:220px; background:rgba(233,69,96,0.08); border-radius:12px; padding:18px;">
                        <h3 style="color:#f27121;">üï∫ Choreography Generator</h3>
                        <p style="font-size:1rem;">Generate unique dance sequences for Bollywood, Kathak, Hip-Hop, and Contemporary styles.</p>
                    </div>
                    <div style="flex:1 1 220px; min-width:220px; background:rgba(233,69,96,0.08); border-radius:12px; padding:18px;">
                        <h3 style="color:#f27121;">üìö Learn & Explore</h3>
                        <p style="font-size:1rem;">Discover the heritage of Indian dance, learn new moves, and save your favorite poses in the gallery.</p>
                    </div>
                </div>
                <div style="margin-top:36px; text-align:center;">
                    <a href="#" class="btn" data-page="about" style="margin-right:15px;">About</a>
                    <a href="#" class="btn secondary" data-page="gallery">View Gallery</a>
                </div>
            </div>
            <div style="margin: 60px auto 0 auto; max-width: 800px; background: rgba(242,113,33,0.07); border-radius: 14px; padding: 22px 18px;">
                <h3 style="color:#e94560; margin-bottom:10px;">‚ú® Why Nritya AI?</h3>
                <ul style="font-size:1.05rem; line-height:1.7; color:#fff; margin-left:20px;">
                    <li>Easy-to-use, browser-based experience</li>
                    <li>Supports multiple Indian and global dance styles</li>
                    <li>Save, review, and share your dance poses and sequences</li>
                    <li>Perfect for solo practice, group choreography, and teaching</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Live Tracking Page -->
    <div class="page" id="tracking">
        <div class="container">
            <h2 style="text-align: center; margin-bottom: 30px; color: #f27121;">Live Motion Tracking</h2>
            <div style="margin-bottom:24px; text-align:center;">
                <label for="musicSelect" style="color:#f27121; font-weight:bold;">Select Music:</label>
                <select id="musicSelect" style="padding:8px; border-radius:8px; margin-left:10px;">
                    <option value="">-- Choose a track --</option>
                    <option value="music1.mp3">Bollywood Groove</option>
                    <option value="music2.mp3">Kathak Beats</option>
                    <option value="music3.mp3">Hip-Hop Jam</option>
                    <option value="music4.mp3">Contemporary Flow</option>
                </select>
                <audio id="musicPlayer" controls style="vertical-align:middle; margin-left:15px; display:none;"></audio>
            </div>
            <div class="tracking-container">
                <div class="video-section">
                    <div class="video-container">
                        <video id="video" autoplay muted playsinline></video>
                        <canvas id="poseCanvas"></canvas>
                        <canvas id="expectedPoseCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
                    </div>
                    <div class="controls">
                        <button id="startTrackingBtn" class="btn">Start Tracking</button>
                        <button id="stopTrackingBtn" class="btn secondary">Stop Tracking</button>
                        <button id="captureBtn" class="btn">Capture Pose</button>
                        <button id="loadExpectedBtn" class="btn secondary">Load Expected Pose</button>
                    </div>
                    <div style="margin-top:10px; color:#f27121; text-align:center;" id="feedbackMsg"></div>
                </div>
                <div class="data-section">
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="frameCount">0</div>
                            <div class="stat-label">Frames</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="poseCount">0</div>
                            <div class="stat-label">Poses</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="accuracy">0%</div>
                            <div class="stat-label">Accuracy</div>
                        </div>
                    </div>
                    <div id="trackingLog" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; font-family: monospace; font-size: 0.9rem;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Choreography Page -->
    <div class="page" id="choreography">
        <div class="container">
            <h2 style="text-align: center; margin-bottom: 30px; color: #f27121;">Choreography Generator</h2>
            <div class="choreo-container">
                <div class="choreo-controls">
                    <div class="dance-style">
                        <label>Dance Style:</label>
                        <select id="danceStyleSelect">
                            <option value="bollywood">Bollywood</option>
                            <option value="kathak">Kathak</option>
                            <option value="hiphop">Hip-Hop</option>
                            <option value="contemporary">Contemporary</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label>Duration (seconds):</label>
                        <input id="choreoDuration" type="number" min="2" max="60" value="10" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #e94560; background: rgba(255,255,255,0.07); color: white;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label>Tempo:</label>
                        <select id="choreoTempo" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #e94560; background: rgba(255,255,255,0.07); color: white;">
                            <option value="slow">Slow</option>
                            <option value="medium" selected>Medium</option>
                            <option value="fast">Fast</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label>Complexity:</label>
                        <select id="choreoComplexity" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #e94560; background: rgba(255,255,255,0.07); color: white;">
                            <option value="beginner">Beginner</option>
                            <option value="intermediate" selected>Intermediate</option>
                            <option value="advanced">Advanced</option>
                        </select>
                    </div>
                    <button id="generateBtn" class="btn" style="width: 100%; margin-bottom: 20px;">Generate Choreography</button>
                    <div style="margin-bottom: 20px;">
                        <button id="playBtn" class="btn">Play</button>
                        <button id="pauseBtn" class="btn secondary">Pause</button>
                        <button id="resetBtn" class="btn secondary">Reset</button>
                        <button id="previewBtn" class="btn secondary" style="float:right;">Preview Moves</button>
                    </div>
                    <div id="choreoMeta" style="margin-bottom: 10px; color: #f27121; font-size: 0.95rem;"></div>
                    <div class="pose-list" id="poseList">
                        <div style="text-align: center; color: #999;">Generate choreography to see poses</div>
                    </div>
                </div>
                <div class="choreo-canvas-container">
                    <canvas id="choreoCanvas"></canvas>
                    <div style="text-align: center; margin-top: 15px;">
                        <span id="currentPose">Pose: 0/0</span>
                        <span style="margin-left: 20px;" id="playbackSpeed">Speed: 1x</span>
                    </div>
                    <div id="previewModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.85); z-index:2000; align-items:center; justify-content:center;">
                        <div style="background:#222; border-radius:15px; padding:30px; max-width:600px; max-height:80vh; overflow:auto; color:white; position:relative;">
                            <button id="closePreviewBtn" style="position:absolute; top:10px; right:15px; background:none; border:none; color:#e94560; font-size:1.5rem; cursor:pointer;">&times;</button>
                            <h3 style="color:#f27121; margin-bottom:15px;">Choreography Moves & Keyframes</h3>
                            <div id="previewContent"></div>
                        </div>
                    </div>
                    <div id="choreoError" style="color:#e94560; text-align:center; margin-top:10px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Gallery Page -->
    <div class="page" id="gallery">
        <div class="container">
            <h2 style="text-align: center; margin-bottom: 30px; color: #f27121;">Pose Gallery</h2>
            <div class="gallery-grid" id="galleryGrid">
                <!-- Gallery items will be populated here -->
            </div>
        </div>
    </div>

    <!-- About Page -->
    <div class="page" id="about">
        <div class="container">
            <h2 style="color:#f27121; text-align:center; margin-bottom:18px;">About Nritya AI</h2>
            <div id="aboutContent" style="margin-bottom:32px;">
                <div style="text-align:center; color:#aaa;">Loading...</div>
            </div>
            <div id="aboutTeam" style="margin-bottom:32px;"></div>
            <div id="aboutPhantomDance" style="margin-bottom:32px;"></div>
            <div id="aboutContact" style="margin-bottom:32px;"></div>
        </div>
    </div>

    <!-- Virtual Dance Instructor Page -->
    <div class="page" id="instructor">
        <div class="container">
            <div class="hero" style="text-align: center; padding: 50px 20px;">
                <h1 style="color: #f27121; font-size: 3rem; margin-bottom: 20px; font-weight: 700;">
                    üé≠ Virtual Dance Instructor
                </h1>
                <p style="font-size: 1.4rem; color: #fff; margin-bottom: 40px; max-width: 600px; margin-left: auto; margin-right: auto; line-height: 1.6;">
                    Experience AI-powered dance learning with real-time pose analysis, voice commands, and interactive lessons
                </p>
                
                <div style="background: linear-gradient(135deg, rgba(242, 113, 33, 0.1), rgba(233, 69, 96, 0.1)); border: 2px solid rgba(242, 113, 33, 0.3); border-radius: 20px; padding: 30px; margin: 30px auto; max-width: 800px;">
                    <h2 style="color: #f27121; margin-bottom: 20px;">üöÄ Enhanced Features</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; text-align: left;">
                        <div>
                            <h3 style="color: #e94560; margin-bottom: 10px;">üéØ Real-time Analysis</h3>
                            <ul style="color: #fff; line-height: 1.6;">
                                <li>Live pose tracking & scoring</li>
                                <li>Movement precision feedback</li>
                                <li>Performance analytics</li>
                            </ul>
                        </div>
                        <div>
                            <h3 style="color: #e94560; margin-bottom: 10px;">üé§ Voice Control</h3>
                            <ul style="color: #fff; line-height: 1.6;">
                                <li>Voice commands for hands-free control</li>
                                <li>Spoken feedback & encouragement</li>
                                <li>Interactive voice responses</li>
                            </ul>
                        </div>
                        <div>
                            <h3 style="color: #e94560; margin-bottom: 10px;">üìà Progress Tracking</h3>
                            <ul style="color: #fff; line-height: 1.6;">
                                <li>Achievement system</li>
                                <li>Learning progress metrics</li>
                                <li>Personalized recommendations</li>
                            </ul>
                        </div>
                        <div>
                            <h3 style="color: #e94560; margin-bottom: 10px;">üé® Interactive Lessons</h3>
                            <ul style="color: #fff; line-height: 1.6;">
                                <li>Step-by-step tutorials</li>
                                <li>Multiple dance styles</li>
                                <li>Adaptive difficulty levels</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 40px;">
                    <button class="btn" onclick="window.open('virtual-instructor.html', '_blank')" style="font-size: 1.2rem; padding: 15px 30px; margin: 10px; background: linear-gradient(135deg, #f27121, #e94560); border: none; border-radius: 50px; color: white; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 8px 25px rgba(242, 113, 33, 0.3);">
                        üöÄ Launch Enhanced Virtual Instructor
                    </button>
                    <br>
                    <button class="btn secondary" onclick="openBasicInstructor()" style="font-size: 1rem; padding: 12px 25px; margin: 10px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(242, 113, 33, 0.5); border-radius: 50px; color: #f27121; cursor: pointer; transition: all 0.3s ease;">
                        üìö Continue with Basic Instructor
                    </button>
                </div>

                <div style="margin-top: 30px; font-size: 0.9rem; color: rgba(255, 255, 255, 0.7);">
                    <p>üí° <strong>Tip:</strong> For the best experience, use the Enhanced Virtual Instructor with camera access enabled</p>
                </div>
            </div>

            <!-- Basic Instructor (Hidden by default) -->
            <div id="basicInstructor" style="display: none;">
                <div style="text-align: center; margin-bottom: 30px;">
                    <h2 style="color:#f27121; margin-bottom: 15px;">üé≠ Basic Virtual Dance Instructor</h2>
                    <p style="color: rgba(255,255,255,0.8); font-size: 1.1rem; margin-bottom: 20px;">
                        Learn dance moves with guided instruction and real-time feedback
                    </p>
                    <button class="btn secondary" onclick="openBasicInstructor()" style="font-size: 0.9rem; padding: 8px 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(242,113,33,0.5);">
                        ‚Üê Back to Enhanced Features
                    </button>
                </div>

                <!-- Enhanced Basic Instructor Layout -->
                <div style="display:grid; grid-template-columns: 1fr 2fr; gap:25px; margin-bottom: 25px;">
                    <!-- Left Panel - Enhanced Controls -->
                    <div style="background:rgba(30,30,60,0.8); border-radius:18px; padding:25px; border: 2px solid rgba(242,113,33,0.3);">
                        <!-- Dance Style Selection -->
                        <div style="margin-bottom: 25px;">
                            <h3 style="color:#f27121; margin-bottom:15px; display: flex; align-items: center; gap: 8px;">
                                üé® Dance Style
                            </h3>
                            <select id="instructorStyleSelect" aria-label="Dance Style" style="width:100%; padding:12px; border-radius:10px; margin-top:8px; background:#2a2a4a; color:white; border: 2px solid rgba(242,113,33,0.3); font-size: 1rem;">
                                <option value="">-- Select style --</option>
                                <option value="bollywood">üï∫ Bollywood</option>
                                <option value="kathak">üíÉ Kathak</option>
                                <option value="hiphop">üé§ Hip-Hop</option>
                                <option value="contemporary">üåü Contemporary</option>
                            </select>
                        </div>

                        <!-- Move Selection -->
                        <div style="margin-bottom: 25px;">
                            <h3 style="color:#f27121; margin-bottom:15px; display: flex; align-items: center; gap: 8px;">
                                üéØ Select Move
                            </h3>
                            <select id="instructorMoveSelect" aria-label="Move" style="width:100%; padding:12px; border-radius:10px; margin-top:8px; background:#2a2a4a; color:white; border: 2px solid rgba(242,113,33,0.3); font-size: 1rem;">
                                <option value="">-- Select move --</option>
                            </select>
                            <div style="display: flex; gap: 10px; margin-top: 15px;">
                                <button class="btn" id="previewInstructorMoveBtn" style="flex: 1; padding: 10px; font-size: 0.9rem;">
                                    üëÅÔ∏è Preview
                                </button>
                                <button class="btn secondary" id="loadInstructorMoveBtn" style="flex: 1; padding: 10px; font-size: 0.9rem;">
                                    üì• Load Move
                                </button>
                            </div>
                        </div>

                        <!-- Difficulty Level -->
                        <div style="margin-bottom: 25px;">
                            <h3 style="color:#f27121; margin-bottom:15px; display: flex; align-items: center; gap: 8px;">
                                üìä Difficulty
                            </h3>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <button class="difficulty-btn active" data-level="beginner" style="flex: 1; min-width: 80px; padding: 8px 12px; border-radius: 20px; border: 2px solid #4CAF50; background: #4CAF50; color: white; font-size: 0.85rem; cursor: pointer; transition: all 0.3s;">
                                    üå± Beginner
                                </button>
                                <button class="difficulty-btn" data-level="intermediate" style="flex: 1; min-width: 80px; padding: 8px 12px; border-radius: 20px; border: 2px solid #FF9800; background: transparent; color: #FF9800; font-size: 0.85rem; cursor: pointer; transition: all 0.3s;">
                                    üöÄ Intermediate
                                </button>
                                <button class="difficulty-btn" data-level="advanced" style="flex: 1; min-width: 80px; padding: 8px 12px; border-radius: 20px; border: 2px solid #F44336; background: transparent; color: #F44336; font-size: 0.85rem; cursor: pointer; transition: all 0.3s;">
                                    üî• Advanced
                                </button>
                            </div>
                        </div>

                        <!-- Session Controls -->
                        <div style="margin-bottom: 20px;">
                            <h3 style="color:#f27121; margin-bottom:15px; display: flex; align-items: center; gap: 8px;">
                                üé¨ Session Controls
                            </h3>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <button class="btn" id="instructorStartBtn" style="width: 100%; padding: 12px; font-size: 1rem; background: linear-gradient(135deg, #4CAF50, #45a049);">
                                    ‚ñ∂Ô∏è Start Session
                                </button>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn secondary" id="instructorPauseBtn" style="flex: 1; padding: 10px; font-size: 0.9rem; display: none;">
                                        ‚è∏Ô∏è Pause
                                    </button>
                                    <button class="btn secondary" id="instructorStopBtn" style="flex: 1; padding: 10px; font-size: 0.9rem;">
                                        ‚èπÔ∏è Stop
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Live Stats -->
                        <div style="background: rgba(242,113,33,0.1); border-radius: 12px; padding: 15px; border: 1px solid rgba(242,113,33,0.3);">
                            <h4 style="color:#f27121; margin-bottom: 10px; font-size: 0.95rem;">üìà Live Performance</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.85rem;">
                                <div style="text-align: center;">
                                    <div style="color: #4CAF50; font-size: 1.2rem; font-weight: bold;" id="basicAccuracy">--</div>
                                    <div style="color: rgba(255,255,255,0.8);">Accuracy</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="color: #FF9800; font-size: 1.2rem; font-weight: bold;" id="basicTiming">--</div>
                                    <div style="color: rgba(255,255,255,0.8);">Timing</div>
                                </div>
                            </div>
                        </div>

                        <!-- Session Status -->
                        <div id="instructorStatus" style="margin-top:15px; color:#f27121; font-size: 0.9rem; text-align: center; padding: 10px; background: rgba(242,113,33,0.1); border-radius: 8px; border: 1px solid rgba(242,113,33,0.3);" aria-live="polite">
                            Ready to start your dance session
                        </div>
                    </div>

                    <!-- Right Panel - Enhanced Video Area -->
                    <div style="background:rgba(30,30,60,0.8); border-radius:18px; padding:20px; border: 2px solid rgba(242,113,33,0.3);">
                        <div style="position:relative; border-radius:15px; overflow: hidden; background:#000; min-height: 400px;">
                            <!-- Reference Canvas -->
                            <canvas id="instructorReferenceCanvas" style="width:100%; height: 200px; border-radius:12px; background:#181818; margin-bottom:15px; border: 2px solid rgba(102,126,234,0.3);"></canvas>
                            
                            <!-- Video Controls -->
                            <video id="instructorVideo" style="width:100%; border-radius:12px; display:none; margin-bottom: 15px;" controls></video>
                            
                            <!-- Webcam Feed -->
                            <canvas id="instructorWebcam" style="width:100%; height: 200px; border-radius:12px; display:none; border: 2px solid rgba(245,87,108,0.3);"></canvas>
                            
                            <!-- Overlay Instructions -->
                            <div id="instructorOverlay" style="position: absolute; top: 10px; left: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 12px; border-radius: 8px; font-size: 0.9rem; display: none;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="color: #f27121;">üéØ</span>
                                    <strong id="currentMoveDisplay">Loading move...</strong>
                                </div>
                                <div id="moveInstructions" style="font-size: 0.85rem; color: rgba(255,255,255,0.9);">
                                    Follow the reference movements shown above
                                </div>
                            </div>

                            <!-- Performance Indicator -->
                            <div id="performanceIndicator" style="position: absolute; bottom: 15px; right: 15px; background: rgba(0,0,0,0.8); color: white; padding: 10px 15px; border-radius: 20px; font-weight: bold; display: none;">
                                <span id="performanceScore">--</span>%
                            </div>
                        </div>

                        <!-- Enhanced Feedback Section -->
                        <div id="instructorFeedback" style="margin-top:15px; padding: 15px; background: rgba(102,126,234,0.1); border-radius: 12px; border: 1px solid rgba(102,126,234,0.3); text-align: center;">
                            <div style="color:#667eea; font-size: 1.1rem; font-weight: bold; margin-bottom: 8px;">
                                Ready to Dance! üï∫üíÉ
                            </div>
                            <div style="color: rgba(255,255,255,0.8); font-size: 0.9rem;">
                                Select a style and move to begin your session
                            </div>
                        </div>

                        <!-- Quick Tips -->
                        <div style="margin-top: 15px; padding: 12px; background: rgba(245,87,108,0.1); border-radius: 10px; border: 1px solid rgba(245,87,108,0.3);">
                            <h4 style="color: #f5576c; margin-bottom: 8px; font-size: 0.9rem;">üí° Quick Tips</h4>
                            <ul style="color: rgba(255,255,255,0.8); font-size: 0.8rem; margin: 0; padding-left: 15px;">
                                <li>Ensure good lighting for better pose detection</li>
                                <li>Position yourself fully within the camera frame</li>
                                <li>Start with beginner moves and progress gradually</li>
                                <li>Focus on form over speed</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Instructor Preview Modal -->
                <div id="instructorPreviewModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.85); z-index:2000; align-items:center; justify-content:center;">
                    <div style="background:rgba(30,30,60,0.95); padding:20px; border-radius:15px; max-width:600px; max-height:80vh; overflow-y:auto; position:relative; border: 2px solid rgba(242,113,33,0.3);">
                        <button id="closeInstructorPreviewBtn" style="position:absolute; top:10px; right:15px; background:none; border:none; color:#e94560; font-size:1.5rem; cursor:pointer;">&times;</button>
                        <h3 style="color:#f27121; margin-bottom:15px;">Move Preview</h3>
                        <div id="instructorPreviewContent"></div>
                    </div>
                </div>

                <!-- Progress and Achievements Section -->
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-top: 20px;">
                    <!-- Progress Timeline -->
                    <div style="background:rgba(30,30,60,0.8); border-radius:15px; padding:20px; border: 2px solid rgba(242,113,33,0.3);">
                        <h3 style="color:#f27121; margin-bottom:15px; display: flex; align-items: center; gap: 8px;">
                            üìà Session Progress
                        </h3>
                        <div style="background: rgba(255,255,255,0.1); height: 8px; border-radius: 4px; margin: 15px 0; overflow: hidden;">
                            <div id="sessionProgress" style="height: 100%; background: linear-gradient(90deg, #f27121, #e94560); width: 0%; transition: width 0.3s ease; border-radius: 4px;"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; color: rgba(255,255,255,0.8); font-size: 0.85rem;">
                            <span>Session: <span id="sessionTime">00:00</span></span>
                            <span>Progress: <span id="progressPercent">0%</span></span>
                        </div>
                        
                        <!-- Recent Scores -->
                        <div style="margin-top: 15px;">
                            <h4 style="color: #667eea; margin-bottom: 10px; font-size: 0.9rem;">Recent Scores</h4>
                            <div id="recentScores" style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <span style="background: rgba(76,175,80,0.2); color: #4CAF50; padding: 4px 8px; border-radius: 12px; font-size: 0.8rem;">Starting...</span>
                            </div>
                        </div>
                    </div>

                    <!-- Mini Achievements -->
                    <div style="background:rgba(30,30,60,0.8); border-radius:15px; padding:20px; border: 2px solid rgba(242,113,33,0.3);">
                        <h3 style="color:#f27121; margin-bottom:15px; display: flex; align-items: center; gap: 8px;">
                            üèÜ Achievements
                        </h3>
                        <div id="miniAchievements" style="display: flex; flex-direction: column; gap: 8px;">
                            <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                <span style="font-size: 1.2rem;">üéØ</span>
                                <div style="font-size: 0.85rem;">
                                    <div style="color: white; font-weight: bold;">First Session</div>
                                    <div style="color: rgba(255,255,255,0.6);">Complete your first dance</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 8px; opacity: 0.5;">
                                <span style="font-size: 1.2rem;">‚≠ê</span>
                                <div style="font-size: 0.85rem;">
                                    <div style="color: white; font-weight: bold;">Score Master</div>
                                    <div style="color: rgba(255,255,255,0.6);">Score 80% or higher</div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 8px; opacity: 0.5;">
                                <span style="font-size: 1.2rem;">üî•</span>
                                <div style="font-size: 0.85rem;">
                                    <div style="color: white; font-weight: bold;">Consistency</div>
                                    <div style="color: rgba(255,255,255,0.6);">5 sessions in a row</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- About Page -->
    <div class="page" id="about">
        <div class="container">
            <h2 style="color:#f27121; text-align:center; margin-bottom:18px;">About Nritya AI</h2>
            <div id="aboutContent" style="margin-bottom:32px;">
                <div style="text-align:center; color:#aaa;">Loading...</div>
            </div>
            <div id="aboutTeam" style="margin-bottom:32px;"></div>
            <div id="aboutPhantomDance" style="margin-bottom:32px;"></div>
            <div id="aboutContact" style="margin-bottom:32px;"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.5/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.5/camera_utils.js"></script>
    <script>
        // === Backend API URL ===
        const BACKEND_URL = "http://127.0.0.1:8000";

        // Utility: Convert canvas to base64 image
        function canvasToBase64(canvas) {
            return canvas.toDataURL("image/png");
        }

        // Utility: Draw pose landmarks
        function drawLandmarks(ctx, landmarks, color="#f27121") {
            if (!landmarks || landmarks.length === 0) return;
            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 4;
            // Draw circles for each landmark
            for (const lm of landmarks) {
                ctx.beginPath();
                ctx.arc(lm.x, lm.y, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.restore();
        }

        // Utility: Compare two sets of landmarks (returns similarity score 0-1)
        function compareLandmarks(live, expected) {
            if (!live || !expected || live.length !== expected.length) return 0;
            let sum = 0, count = 0;
            for (let i = 0; i < live.length; ++i) {
                // Only compare visible landmarks
                if (live[i].visibility > 0.5 && expected[i].visibility > 0.5) {
                    const dx = live[i].x - expected[i].x;
                    const dy = live[i].y - expected[i].y;
                    sum += Math.sqrt(dx * dx + dy * dy);
                    count++;
                }
            }
            if (count === 0) return 0;
            // Normalize: lower is better, invert for similarity
            const avgDist = sum / count;
            // Assume max reasonable distance is 0.5 (normalized), similarity = 1 - (avgDist / 0.5)
            return Math.max(0, 1 - avgDist / 0.5);
        }

        // Router Class for Page Navigation
        class Router {
            constructor() {
                this.currentPage = 'home';
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.navigateTo(link.dataset.page);
                    });
                });

                document.querySelectorAll('[data-page]').forEach(element => {
                    element.addEventListener('click', (e) => {
                        if (element.dataset.page) {
                            e.preventDefault();
                            this.navigateTo(element.dataset.page);
                        }
                    });
                });
            }

            navigateTo(page) {
                // Hide current page
                document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));

                // Show new page
                document.getElementById(page).classList.add('active');
                document.querySelector(`[data-page="${page}"]`).classList.add('active');

                this.currentPage = page;
                
                // Initialize page-specific functionality
                this.initializePage(page);
            }

            initializePage(page) {
                switch(page) {
                    case 'tracking':
                        if (window.liveTracker) window.liveTracker.init();
                        break;
                    case 'choreography':
                        if (window.choreoGenerator) window.choreoGenerator.init();
                        break;
                    case 'gallery':
                        if (window.galleryManager) window.galleryManager.loadGallery();
                        break;
                    case 'instructor':
                        // Reset instructor page to hero view
                        const heroSection = document.querySelector('#instructor .hero');
                        const basicInstructor = document.getElementById('basicInstructor');
                        if (heroSection && basicInstructor) {
                            heroSection.style.display = 'block';
                            basicInstructor.style.display = 'none';
                        }
                        break;
                }
            }
        }

        // Live Tracking Class
        class LiveTracker {
            constructor() {
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.expectedCanvas = null;
                this.expectedCtx = null;
                this.isTracking = false;
                this.stats = { frameCount: 0, poseCount: 0, accuracy: 0 };
                this.lastPose = null;
                this.loading = false;
                this.expectedPose = null;
                this.musicSelected = false;
                this.musicPlayer = null;
                this.musicSelect = null;
            }

            init() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('poseCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.expectedCanvas = document.getElementById('expectedPoseCanvas');
                this.expectedCtx = this.expectedCanvas.getContext('2d');
                this.expectedCanvas.width = this.canvas.width;
                this.expectedCanvas.height = this.canvas.height;
                this.setupCamera();
                this.setupEventListeners();
                this.musicPlayer = document.getElementById('musicPlayer');
                this.musicSelect = document.getElementById('musicSelect');
                this.musicSelected = false;
                this.setupMusicSelection();
                document.getElementById('feedbackMsg').textContent = '';
            }

            async setupCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    this.video.srcObject = stream;
                    this.video.onloadedmetadata = () => {
                        this.canvas.width = this.video.videoWidth;
                        this.canvas.height = this.video.videoHeight;
                        this.expectedCanvas.width = this.video.videoWidth;
                        this.expectedCanvas.height = this.video.videoHeight;
                    };
                } catch (err) {
                    this.log('Camera access denied');
                }
            }

            setupEventListeners() {
                document.getElementById('startTrackingBtn').onclick = () => this.startTracking();
                document.getElementById('stopTrackingBtn').onclick = () => this.stopTracking();
                document.getElementById('captureBtn').onclick = () => this.captureFrame();
                document.getElementById('loadExpectedBtn').onclick = () => this.loadExpectedPose();
            }

            setupMusicSelection() {
                this.musicPlayer.pause();
                this.musicPlayer.style.display = 'none';
                this.musicSelect.value = "";
                // Only allow tracking after music is selected
                document.getElementById('startTrackingBtn').disabled = true;
                this.musicSelect.onchange = () => {
                    const val = this.musicSelect.value;
                    if (val) {
                        this.musicPlayer.src = `music/${val}`;
                        this.musicPlayer.style.display = '';
                        this.musicSelected = true;
                        document.getElementById('startTrackingBtn').disabled = false;
                    } else {
                        this.musicPlayer.pause();
                        this.musicPlayer.style.display = 'none';
                        this.musicSelected = false;
                        document.getElementById('startTrackingBtn').disabled = true;
                    }
                };
            }

            async loadExpectedPose() {
                // For demo: prompt user to upload a pose JSON file
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,application/json';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const text = await file.text();
                    try {
                        const data = JSON.parse(text);
                        if (data.landmarks && data.landmarks.length > 0) {
                            this.expectedPose = data.landmarks;
                            this.drawExpectedPose();
                            document.getElementById('feedbackMsg').textContent = 'Expected pose loaded!';
                        } else {
                            document.getElementById('feedbackMsg').textContent = 'Invalid pose file.';
                        }
                    } catch {
                        document.getElementById('feedbackMsg').textContent = 'Invalid JSON file.';
                    }
                };
                input.click();
            }

            drawExpectedPose() {
                this.expectedCtx.clearRect(0, 0, this.expectedCanvas.width, this.expectedCanvas.height);
                if (!this.expectedPose) return;
                // Draw expected pose in blue
                const landmarks = this.expectedPose.map(lm => ({
                    x: lm.x * this.expectedCanvas.width,
                    y: lm.y * this.expectedCanvas.height,
                    visibility: lm.visibility
                }));
                drawLandmarks(this.expectedCtx, landmarks, "#2196f3");
            }

            startTracking() {
                if (this.isTracking) return;
                this.isTracking = true;
                this.log('Started live tracking');
                // Play music when tracking starts
                if (this.musicPlayer && this.musicPlayer.src) {
                    this.musicPlayer.currentTime = 0;
                    this.musicPlayer.play();
                }
                this.trackingLoop();
            }

            stopTracking() {
                this.isTracking = false;
                this.log('Stopped tracking');
                if (this.musicPlayer) {
                    this.musicPlayer.pause();
                }
            }

            async trackingLoop() {
                if (!this.isTracking) return;

                this.stats.frameCount++;
                this.updateStats();

                // Draw video frame
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);

                // Draw expected pose overlay
                this.drawExpectedPose();

                // Send frame to backend for pose detection every 3rd frame
                if (this.stats.frameCount % 3 === 0 && !this.loading) {
                    this.loading = true;
                    try {
                        const imgData = this.canvas.toDataURL("image/jpeg");
                        const res = await fetch(`${BACKEND_URL}/pose`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ image_data: imgData })
                        });
                        if (res.ok) {
                            const data = await res.json();
                            if (data.landmarks && data.landmarks.length > 0) {
                                this.lastPose = data;
                                this.stats.poseCount++;
                                this.stats.accuracy = Math.round((this.stats.poseCount / this.stats.frameCount) * 100);
                                // Draw landmarks
                                this.drawPoseLandmarks(data.landmarks);
                                // Compare with expected pose if loaded
                                if (this.expectedPose) {
                                    const liveNorm = data.landmarks.map(lm => ({
                                        x: lm.x,
                                        y: lm.y,
                                        visibility: lm.visibility
                                    }));
                                    const sim = compareLandmarks(liveNorm, this.expectedPose);
                                    let msg = '';
                                    if (sim > 0.85) msg = 'Great! Your pose matches the instructor!';
                                    else if (sim > 0.65) msg = 'Good! Try to match the pose more closely.';
                                    else msg = 'Keep practicing to match the instructor pose!';
                                    document.getElementById('feedbackMsg').textContent = `Similarity: ${(sim*100).toFixed(1)}%. ${msg}`;
                                } else {
                                    document.getElementById('feedbackMsg').textContent = '';
                                }
                            }
                        } else {
                            const err = await res.json();
                            this.log("Pose error: " + (err.detail || "Unknown"));
                        }
                    } catch (e) {
                        this.log("API error: " + e.message);
                    }
                    this.loading = false;
                } else if (this.lastPose && this.lastPose.landmarks) {
                    this.drawPoseLandmarks(this.lastPose.landmarks);
                }

                requestAnimationFrame(() => this.trackingLoop());
            }

            drawPoseLandmarks(landmarks) {
                // Assume landmarks are normalized [0,1], scale to canvas
                for (const lm of landmarks) {
                    lm.x = lm.x * this.canvas.width;
                    lm.y = lm.y * this.canvas.height;
                }
                drawLandmarks(this.ctx, landmarks, "#f27121");
            }

            captureFrame() {
                this.log('Frame captured');
                // Save to gallery with thumbnail
                if (window.galleryManager) {
                    const name = this.lastPose && this.lastPose.pose_analysis && this.lastPose.pose_analysis.pose_type
                        ? this.lastPose.pose_analysis.pose_type
                        : "Captured Pose";
                    const img = canvasToBase64(this.canvas);
                    window.galleryManager.addPose(name, new Date(), img);
                }
            }

            updateStats() {
                document.getElementById('frameCount').textContent = this.stats.frameCount;
                document.getElementById('poseCount').textContent = this.stats.poseCount;
                document.getElementById('accuracy').textContent = this.stats.accuracy + '%';
            }

            log(message) {
                const logDiv = document.getElementById('trackingLog');
                const time = new Date().toLocaleTimeString();
                logDiv.innerHTML += `[${time}] ${message}<br>`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }
        }

        // Choreography Generator Class
        class ChoreographyGenerator {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.currentSequence = [];
                this.currentPoseIndex = 0;
                this.isPlaying = false;
                this.playbackSpeed = 1000;
                this.loading = false;
                this.meta = {};
            }

            init() {
                this.canvas = document.getElementById('choreoCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.setupEventListeners();
                this.clearMeta();
                document.getElementById('choreoError').textContent = '';
            }

            setupEventListeners() {
                document.getElementById('generateBtn').onclick = () => this.generateChoreography();
                document.getElementById('playBtn').onclick = () => this.playSequence();
                document.getElementById('pauseBtn').onclick = () => this.pauseSequence();
                document.getElementById('resetBtn').onclick = () => this.resetSequence();
                document.getElementById('previewBtn').onclick = () => this.previewMoves();
                document.getElementById('closePreviewBtn').onclick = () => this.closePreview();
            }

            async generateChoreography() {
                const style = document.getElementById('danceStyleSelect').value;
                const duration = parseInt(document.getElementById('choreoDuration').value) || 10;
                const tempo = document.getElementById('choreoTempo').value;
                const complexity = document.getElementById('choreoComplexity').value;
                this.loading = true;
                document.getElementById('generateBtn').textContent = "Loading...";
                document.getElementById('choreoError').textContent = '';
                try {
                    const res = await fetch(`${BACKEND_URL}/choreography`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ style, duration, tempo, complexity })
                    });
                    if (res.ok) {
                        const data = await res.json();
                        this.currentSequence = data.sequence || [];
                        this.meta = {
                            duration: data.duration,
                            tempo: data.tempo,
                            complexity: data.complexity,
                            total_moves: data.total_moves
                        };
                        this.updateMeta();
                        this.updatePoseList();
                        this.drawPose(0);
                        this.updateCurrentPose();
                    } else {
                        const err = await res.json();
                        document.getElementById('choreoError').textContent = "Choreography error: " + (err.detail || "Unknown");
                        this.clearMeta();
                        this.updatePoseList();
                    }
                } catch (e) {
                    document.getElementById('choreoError').textContent = "API error: " + e.message;
                    this.clearMeta();
                    this.updatePoseList();
                }
                document.getElementById('generateBtn').textContent = "Generate Choreography";
                this.loading = false;
            }

            updateMeta() {
                const meta = this.meta;
                document.getElementById('choreoMeta').innerHTML =
                    `<b>Duration:</b> ${meta.duration}s &nbsp; <b>Tempo:</b> ${meta.tempo} &nbsp; <b>Complexity:</b> ${meta.complexity} &nbsp; <b>Total Moves:</b> ${meta.total_moves}`;
            }

            clearMeta() {
                document.getElementById('choreoMeta').innerHTML = '';
                this.meta = {};
            }

            updatePoseList() {
                const poseList = document.getElementById('poseList');
                poseList.innerHTML = '';
                if (!this.currentSequence.length) {
                    poseList.innerHTML = '<div style="text-align: center; color: #999;">No choreography generated</div>';
                    return;
                }
                this.currentSequence.forEach((pose, index) => {
                    const poseItem = document.createElement('div');
                    poseItem.className = 'pose-item';
                    poseItem.innerHTML = `
                        <span>${index + 1}. ${pose.name}</span>
                        <span>${pose.keyframes.length} keyframes</span>
                    `;
                    poseItem.onclick = () => this.selectPose(index);
                    poseList.appendChild(poseItem);
                });
            }

            selectPose(index) {
                this.currentPoseIndex = index;
                this.drawPose(index);
                this.updateCurrentPose();
                document.querySelectorAll('.pose-item').forEach((item, i) => {
                    item.classList.toggle('active', i === index);
                });
            }

            drawPose(index) {
                if (!this.currentSequence[index]) return;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // Stylized stick figure for choreography
                const pose = this.currentSequence[index];
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                this.ctx.strokeStyle = '#f27121';
                this.ctx.lineWidth = 4;
                this.ctx.shadowColor = '#f27121';
                this.ctx.shadowBlur = 10;
                // Head
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY - 80, 25, 0, 2 * Math.PI);
                this.ctx.stroke();
                // Body
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY - 55);
                this.ctx.lineTo(centerX, centerY + 40);
                this.ctx.stroke();
                // Arms
                this.ctx.beginPath();
                this.ctx.moveTo(centerX - 40, centerY - 20);
                this.ctx.lineTo(centerX + 40, centerY - 20);
                this.ctx.stroke();
                // Legs
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY + 40);
                this.ctx.lineTo(centerX - 25, centerY + 90);
                this.ctx.moveTo(centerX, centerY + 40);
                this.ctx.lineTo(centerX + 25, centerY + 90);
                this.ctx.stroke();
                // Add pose name
                this.ctx.fillStyle = '#e94560';
                this.ctx.font = '20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(pose.name, centerX, centerY + 120);
            }

            playSequence() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                this.animateSequence();
            }

            pauseSequence() {
                this.isPlaying = false;
            }

            resetSequence() {
                this.isPlaying = false;
                this.currentPoseIndex = 0;
                this.updateCurrentPose();
                if (this.currentSequence.length > 0) {
                    this.drawPose(0);
                }
            }

            animateSequence() {
                if (!this.isPlaying || this.currentSequence.length === 0) return;
                this.drawPose(this.currentPoseIndex);
                this.updateCurrentPose();
                this.currentPoseIndex = (this.currentPoseIndex + 1) % this.currentSequence.length;
                setTimeout(() => this.animateSequence(), this.playbackSpeed);
            }

            updateCurrentPose() {
                document.getElementById('currentPose').textContent =
                    `Pose: ${this.currentPoseIndex + 1}/${this.currentSequence.length}`;
            }

            async previewMoves() {
                // Fetch preview from backend
                const style = document.getElementById('danceStyleSelect').value;
                const previewModal = document.getElementById('previewModal');
                const previewContent = document.getElementById('previewContent');
                previewContent.innerHTML = '<div style="color:#999;">Loading...</div>';
                previewModal.style.display = 'flex';
                try {
                    const res = await fetch(`${BACKEND_URL}/choreography/preview`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ style })
                    });
                    if (res.ok) {
                        const data = await res.json();
                        if (data.moves && data.moves.length > 0) {
                            previewContent.innerHTML = data.moves.map((move, idx) => `
                                <div style="margin-bottom:18px;">
                                    <b style="color:#f27121;">${idx + 1}. ${move.name}</b>
                                    <div style="font-size:0.95em; margin-bottom:4px;">Duration: ${move.duration}s</div>
                                    <div style="font-size:0.93em; color:#aaa;">
                                        Keyframes:
                                        <pre style="background:#181818; color:#fff; border-radius:7px; padding:7px; font-size:0.92em; overflow-x:auto;">${JSON.stringify(move.keyframes, null, 2)}</pre>
                                    </div>
                                </div>
                            `).join('');
                        } else {
                            previewContent.innerHTML = '<div style="color:#999;">No moves found for this style.</div>';
                        }
                    } else {
                        previewContent.innerHTML = '<div style="color:#e94560;">Failed to load preview.</div>';
                    }
                } catch (e) {
                    previewContent.innerHTML = '<div style="color:#e94560;">Error: ' + e.message + '</div>';
                }
            }

            closePreview() {
                document.getElementById('previewModal').style.display = 'none';
            }
        }

        // Gallery Manager Class
        class GalleryManager {
            constructor() {
                this.poses = JSON.parse(localStorage.getItem('savedPoses') || '[]');
            }

            loadGallery() {
                const grid = document.getElementById('galleryGrid');
                grid.innerHTML = '';
                if (this.poses.length === 0) {
                    grid.innerHTML = '<div style="text-align: center; grid-column: 1/-1; color: #999;">No poses saved yet</div>';
                    // Add clear button only if poses exist
                    document.getElementById('galleryClearBtn')?.remove();
                    return;
                }
                this.poses.forEach((pose, index) => {
                    const item = document.createElement('div');
                    item.className = 'gallery-item';
                    item.innerHTML = `
                        <div class="gallery-thumbnail" style="background-image:url('${pose.img || ''}'); background-size:cover; background-position:center;"></div>
                        <h3>${pose.name}</h3>
                        <p>${new Date(pose.timestamp).toLocaleDateString()}</p>
                        <button class="btn" onclick="window.galleryManager.deletePose(${index})">Delete</button>
                    `;
                    grid.appendChild(item);
                });
                // Add clear all button
                if (!document.getElementById('galleryClearBtn')) {
                    const clearBtn = document.createElement('button');
                    clearBtn.id = 'galleryClearBtn';
                    clearBtn.className = 'btn secondary';
                    clearBtn.textContent = 'Clear Gallery';
                    clearBtn.onclick = () => this.clearGallery();
                    grid.parentElement.insertBefore(clearBtn, grid);
                }
            }

            addPose(name, timestamp, img) {
                this.poses.push({ name, timestamp, img });
                localStorage.setItem('savedPoses', JSON.stringify(this.poses));
                this.loadGallery();
            }

            deletePose(index) {
                this.poses.splice(index, 1);
                localStorage.setItem('savedPoses', JSON.stringify(this.poses));
                this.loadGallery();
            }

            clearGallery() {
                if (confirm("Clear all saved poses?")) {
                    this.poses = [];
                    localStorage.removeItem('savedPoses');
                    this.loadGallery();
                }
            }
        }

        // About Page Loader
        async function loadAboutPage() {
            const aboutDiv = document.getElementById('aboutContent');
            const aboutTeam = document.getElementById('aboutTeam');
            const aboutPhantomDance = document.getElementById('aboutPhantomDance');
            const aboutContact = document.getElementById('aboutContact');
            aboutDiv.innerHTML = '<div style="text-align:center; color:#aaa;">Loading...</div>';
            aboutTeam.innerHTML = '';
            aboutPhantomDance.innerHTML = '';
            aboutContact.innerHTML = '';

            try {
                const res = await fetch(`${BACKEND_URL}/about`);
                if (!res.ok) throw new Error("Failed to load");
                const data = await res.json();
                aboutDiv.innerHTML = `
                    <div style="margin-bottom:24px;">
                        <p style="font-size:1.15rem; line-height:1.7; text-align:center;">
                            <b>${data.app}</b> - ${data.description}
                        </p>
                    </div>
                    <div style="background:rgba(233,69,96,0.08); border-radius:12px; padding:18px; margin-bottom:24px;">
                        <h3 style="color:#f27121;">Indian Dance Heritage</h3>
                        <ul>
                            ${data.heritage.map(h => `<li><b>${h.style}:</b> ${h.desc}</li>`).join('')}
                        </ul>
                    </div>
                    <div style="margin-bottom:24px;">
                        <h3 style="color:#f27121;">Our Mission</h3>
                        <p>${data.mission}</p>
                    </div>
                    <div style="color:#aaa; text-align:right;">Version: ${data.version}</div>
                `;
                aboutTeam.innerHTML = `
                    <div style="background:rgba(30,30,60,0.7); border-radius:12px; padding:18px;">
                        <h3 style="color:#f27121;">Our Team</h3>
                        <ul style="list-style:none; padding:0;">
                            ${data.team && Array.isArray(data.team)
                                ? data.team.map(member => `<li><b>${member.name}</b> ‚Äì ${member.role}</li>`).join('')
                                : `<li><b>Reya Garg</b> ‚Äì Full Stack Developer</li>`}
                        </ul>
                    </div>
                `;
                aboutPhantomDance.innerHTML = `
                    <div style="background:rgba(242,113,33,0.07); border-radius:12px; padding:18px;">
                        <h3 style="color:#e94560;">PhantomDance Dataset</h3>
                        <p>
                            <b>PhantomDance</b> is an open choreography dataset powering the Virtual Dance Instructor and Choreography Generator.<br>
                            <span style="color:#f27121;">You can select reference moves directly from this curated library for live feedback and practice.</span>
                        </p>
                        <ul style="margin-top:10px;">
                            <li>Includes authentic Indian and global dance steps</li>
                            <li>Used for both real-time feedback and pre-built choreography</li>
                        </ul>
                        <div style="margin-top:10px; font-size:0.95em; color:#aaa;">
                            <b>Source:</b> <a href="https://github.com/libuyu/PhantomDanceDataset" target="_blank" style="color:#f27121;">PhantomDance on GitHub</a>
                        </div>
                    </div>
                `;
                aboutContact.innerHTML = `
                    <div style="background:rgba(233,69,96,0.08); border-radius:12px; padding:18px;">
                        <h3 style="color:#f27121;">Contact & Credits</h3>
                        <p>
                            For feedback, collaboration, or dataset contributions:<br>
                            <a href="mailto:reyagarg13@gmail.com" style="color:#f27121;">reyagarg13@gmail.com</a>
                        </p>
                        <p style="font-size:0.95em; color:#aaa;">
                            Special thanks to the open-source dance and AI communities.
                        </p>
                    </div>
                `;
            } catch {
                aboutDiv.innerHTML = '<div style="color:#e94560; text-align:center;">Could not load about info.</div>';
            }
        }

        // --- Enhanced Virtual Dance Instructor ---
        class VirtualDanceInstructor {
            restart() {
                this.stop();
                // Reset feedback, similarity, and UI
                this.similarityHistory = [];
                this.feedbackDetails = null;
                this.renderFeedbackChart();
                this.renderDetailedFeedback();
                document.getElementById('instructorStatus').textContent = 'Restarting instructor...';
                // Only restart if a move is loaded
                if (Array.isArray(this.expectedLandmarks) && this.expectedLandmarks.length > 0) {
                    setTimeout(() => this.start(), 400);
                } else {
                    document.getElementById('instructorStatus').textContent = 'Load a move first.';
                }
            }
            // Add missing method to prevent errors
            updateSidebarInfo() {
                // You can implement sidebar updates here if needed
            }
            constructor() {
                this.reference = null;
                this.isRunning = false;
                this.expectedLandmarks = null;
                this.poseInstance = null;
                this.camera = null;
                this.styles = [];
                this.moves = {};
                this.motionLabels = [];
                this.lastSimilarity = null;
                this.similarityHistory = [];
                this.feedbackDetails = null;
                this.feedbackTimer = null;
            }

            async init() {
                await this.populateStyleSelect();
                document.getElementById('instructorStyleSelect').onchange = () => {
                    this.populateEnhancedMotionDropdown();
                    this.clearStatus();
                };
                document.getElementById('instructorMoveSelect').onchange = () => this.clearStatus();
                document.getElementById('previewInstructorMoveBtn').onclick = () => this.previewMove();
                document.getElementById('closeInstructorPreviewBtn').onclick = () => this.closePreview();
                document.getElementById('loadInstructorMoveBtn').onclick = () => this.loadSelectedMove();
                document.getElementById('instructorStartBtn').onclick = () => this.start();
                document.getElementById('instructorStopBtn').onclick = () => this.stop();
                document.getElementById('restartInstructorBtn').onclick = () => this.restart();
                document.getElementById('instructorStatus').textContent = '';
                document.getElementById('instructorFeedback').textContent = '';
                document.getElementById('instructorVideo').style.display = 'none';
                document.getElementById('instructorWebcam').style.display = 'none';
                document.getElementById('instructorReferenceCanvas').style.display = '';
                this.expectedLandmarks = null;
                this.referenceAnimation = null;
                this.similarityHistory = [];
                this.feedbackDetails = null;
                this.renderFeedbackChart();
                this.renderDetailedFeedback();
                this.updateSidebarInfo();
                document.getElementById('moveNameDisplay').textContent = '';
                document.getElementById('moveStyleDisplay').textContent = '';
            }

            async populateStyleSelect() {
                const styleSelect = document.getElementById('instructorStyleSelect');
                styleSelect.innerHTML = `<option value="">-- Select style --</option>`;
                try {
                    const res = await fetch(`${BACKEND_URL}/choreography/styles`);
                    const data = await res.json();
                    this.styles = data.styles;
                    for (const style of this.styles) {
                        const opt = document.createElement('option');
                        opt.value = style;
                        opt.textContent = style.charAt(0).toUpperCase() + style.slice(1);
                        styleSelect.appendChild(opt);
                    }
                } catch {
                    styleSelect.innerHTML += `<option value="bollywood">Bollywood</option>
                        <option value="kathak">Kathak</option>
                        <option value="hiphop">Hip-Hop</option>
                        <option value="contemporary">Contemporary</option>
                        <option value="ballet">Ballet</option>`;
                }
                await this.populateEnhancedMotionDropdown();
            }

            async populateEnhancedMotionDropdown() {
                const style = document.getElementById('instructorStyleSelect').value;
                const moveSelect = document.getElementById('instructorMoveSelect');
                moveSelect.innerHTML = `<option value="">-- Select move --</option>`;
                this.moveMap = {};
                if (!style) return;
                try {
                    const res = await fetch(`${BACKEND_URL}/choreography/preview`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ style })
                    });
                    if (!res.ok) throw new Error("Failed to fetch moves: " + res.status);
                    const data = await res.json();
                    let moves = [];
                    if (Array.isArray(data)) {
                        moves = data;
                    } else if (Array.isArray(data.moves)) {
                        moves = data.moves;
                    }
                    if (moves.length > 0) {
                        for (const move of moves) {
                            if (!move || !move.name) continue;
                            this.moveMap[move.name] = move;
                            const opt = document.createElement('option');
                            opt.value = move.name;
                            let duration = move.duration || (move.meta && move.meta.duration) || "";
                            opt.textContent = move.name + (duration ? ` (${duration}s)` : "");
                            moveSelect.appendChild(opt);
                        }
                    } else {
                        // Add fallback moves if no moves found from API
                        this.addFallbackMoves(style, moveSelect);
                    }
                } catch (err) {
                    console.error("Error loading moves:", err);
                    // Add fallback moves when API fails
                    this.addFallbackMoves(style, moveSelect);
                }
            }

            addFallbackMoves(style, moveSelect) {
                const fallbackMoves = {
                    'bollywood': ['Thumri Basic', 'Hip Circle', 'Arm Wave', 'Step Touch', 'Bhangra Shoulder'],
                    'kathak': ['Tatkar Basic', 'Chakkars', 'Hand Mudra', 'Pirouette', 'Aamad'],
                    'hiphop': ['Body Wave', 'Pop Lock', 'Chest Pop', 'Arm Isolations', 'Step Cross'],
                    'contemporary': ['Port de Bras', 'Spiral', 'Floor Work', 'Contraction', 'Release']
                };

                const moves = fallbackMoves[style] || ['Basic Move 1', 'Basic Move 2', 'Basic Move 3'];
                moves.forEach(moveName => {
                    const opt = document.createElement('option');
                    opt.value = moveName;
                    opt.textContent = moveName;
                    moveSelect.appendChild(opt);
                });
            }

            clearStatus() {
                document.getElementById('instructorStatus').textContent = '';
                document.getElementById('instructorFeedback').textContent = '';
                this.similarityHistory = [];
                this.renderFeedbackChart();
                this.updateSidebarInfo();
            }

            async previewMove() {
                const style = document.getElementById('instructorStyleSelect').value;
                const moveName = document.getElementById('instructorMoveSelect').value;
                if (!style || !moveName) {
                    this.updateBasicStatus('Select a style and move first.', 'warning');
                    return;
                }

                const previewModal = document.getElementById('instructorPreviewModal');
                const previewContent = document.getElementById('instructorPreviewContent');
                
                try {
                    const res = await fetch(`${BACKEND_URL}/choreography/move?style=${encodeURIComponent(style)}&name=${encodeURIComponent(moveName)}`);
                    if (!res.ok) throw new Error("Move preview fetch failed: " + res.status);
                    const move = await res.json();
                    if (move.keyframes && move.keyframes.length > 0) {
                        previewContent.innerHTML = `
                            <b style="color:#f27121;">${move.name}</b>
                            <div style="font-size:0.95em; margin-bottom:4px;">Duration: ${move.duration || ""}s</div>
                            <div style="font-size:0.93em; color:#aaa;">
                                Keyframes:
                                <pre style="background:#181818; color:#fff; border-radius:7px; padding:7px; font-size:0.92em; overflow-x:auto;">${JSON.stringify(move.keyframes, null, 2)}</pre>
                            </div>
                        `;
                        previewModal.style.display = 'flex';
                    } else {
                        this.updateBasicStatus('No keyframes for this move.', 'warning');
                    }
                } catch (err) {
                    console.error("Error loading move preview:", err);
                    // Fallback preview when backend is not available
                    previewContent.innerHTML = `
                        <div style="color:#f27121; font-size: 1.1rem; margin-bottom: 15px;">
                            <strong>${style.toUpperCase()}: ${moveName}</strong>
                        </div>
                        <div style="background: rgba(102,126,234,0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                            <h4 style="color: #667eea; margin-bottom: 10px;">Preview Instructions:</h4>
                            <p style="color: rgba(255,255,255,0.9); line-height: 1.4;">
                                This move combines traditional ${style} techniques with modern expression. 
                                Focus on fluid movements and maintain proper posture throughout the sequence.
                            </p>
                        </div>
                        <div style="background: rgba(245,87,108,0.1); padding: 15px; border-radius: 10px;">
                            <h4 style="color: #f5576c; margin-bottom: 10px;">Key Points:</h4>
                            <ul style="color: rgba(255,255,255,0.8); padding-left: 20px;">
                                <li>Start with a strong foundation stance</li>
                                <li>Keep your core engaged throughout</li>
                                <li>Express emotion through facial expressions</li>
                                <li>Maintain rhythm and timing</li>
                                <li>End with a graceful finishing pose</li>
                            </ul>
                        </div>
                        <div style="margin-top: 15px; padding: 10px; background: rgba(242,113,33,0.1); border-radius: 8px; font-size: 0.9rem; color: rgba(255,255,255,0.7);">
                            <em>üí° Tip: Practice slowly first, then gradually increase speed as you master the movements.</em>
                        </div>
                    `;
                    previewModal.style.display = 'flex';
                    this.updateBasicStatus('Preview loaded (offline mode)', 'info');
                }
            }

            closePreview() {
                document.getElementById('instructorPreviewModal').style.display = 'none';
            }

            async loadSelectedMove() {
                const style = document.getElementById('instructorStyleSelect').value;
                const moveName = document.getElementById('instructorMoveSelect').value;
                if (!style || !moveName) {
                    document.getElementById('instructorStatus').textContent = 'Select a style and move.';
                    this.expectedLandmarks = null;
                    return;
                }
                // Use the move object from the map if available
                const moveObj = this.moveMap && this.moveMap[moveName] ? this.moveMap[moveName] : null;
                try {
                    let move = null;
                    if (moveObj) {
                        move = moveObj;
                    } else {
                        // Try POST first (for some backends), fallback to GET if fails
                        let res = await fetch(`${BACKEND_URL}/choreography/move`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ style, name: moveName })
                        });
                        if (res.ok) {
                            move = await res.json();
                        } else {
                            // fallback to GET
                            res = await fetch(`${BACKEND_URL}/choreography/move?style=${encodeURIComponent(style)}&name=${encodeURIComponent(moveName)}`);
                            if (!res.ok) throw new Error("Move GET fallback failed: " + res.status);
                            move = await res.json();
                        }
                    }
                    console.debug("[Instructor] Loaded move object:", move);
                    if (!move) {
                        document.getElementById('instructorStatus').textContent = 'Move object not found.';
                        this.expectedLandmarks = null;
                        return;
                    }
                    if (move.landmarks && Array.isArray(move.landmarks) && move.landmarks.length > 0) {
                        this.reference = { type: 'pose', landmarks: move.landmarks, name: move.name, style: move.style };
                        this.expectedLandmarks = move.landmarks;
                        document.getElementById('instructorStatus').textContent = `Loaded: ${move.name}`;
                        this.showReferenceAnimation(move);
                        this.updateSidebarInfo();
                        // Animate move name if element exists
                        const moveNameDiv = document.getElementById('moveNameDisplay');
                        if (moveNameDiv) {
                            moveNameDiv.style.opacity = 0;
                            setTimeout(() => { moveNameDiv.style.opacity = 1; }, 100);
                        }
                    } else if (move.keyframes && Array.isArray(move.keyframes) && move.keyframes.length > 0) {
                        this.reference = { type: 'keyframes', keyframes: move.keyframes, name: move.name, style: move.style };
                        // For keyframe-only moves, set expectedLandmarks to dummy zeros (so instructor can still start)
                        this.expectedLandmarks = Array.from({length: 33}, () => ({x: 0, y: 0, z: 0, visibility: 0}));
                        document.getElementById('instructorStatus').textContent = `Loaded: ${move.name} (keyframes only)`;
                        this.showReferenceAnimation(move);
                        this.updateSidebarInfo();
                        const moveNameDiv = document.getElementById('moveNameDisplay');
                        if (moveNameDiv) {
                            moveNameDiv.style.opacity = 0;
                            setTimeout(() => { moveNameDiv.style.opacity = 1; }, 100);
                        }
                    } else {
                        // Accept moves with either landmarks or keyframes, but if neither, show error
                        document.getElementById('instructorStatus').textContent = 'Selected move has no reference pose or keyframes.';
                        this.expectedLandmarks = null;
                        console.error("Move object missing landmarks and keyframes:", move);
                    }
                } catch (err) {
                    // Show actual error message for easier debugging
                    document.getElementById('instructorStatus').textContent = 'Could not load move: ' + (err && err.message ? err.message : err);
                    this.expectedLandmarks = null;
                    console.error("Error loading move:", err, moveObj);
                }
            }

            showReferenceAnimation(move) {
                // Enhanced: Draw stick figure if landmarks exist, else show move name
                const canvas = document.getElementById('instructorReferenceCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (move.landmarks && Array.isArray(move.landmarks) && move.landmarks.length > 0) {
                    // Draw landmarks as stick figure
                    this.drawStickFigure(ctx, move.landmarks, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = '#f27121';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(move.name, canvas.width / 2, canvas.height / 2);
                }
            }

            drawStickFigure(ctx, landmarks, width, height) {
                // Simple stick figure drawing using MediaPipe connections
                const connections = [
                    [11, 13], [13, 15], [12, 14], [14, 16], // arms
                    [11, 12], // shoulders
                    [23, 24], // hips
                    [11, 23], [12, 24], // torso
                    [23, 25], [25, 27], [24, 26], [26, 28], // legs
                    [27, 31], [28, 32], // feet
                ];
                ctx.save();
                ctx.strokeStyle = "#f27121";
                ctx.lineWidth = 4;
                // Scale normalized landmarks to canvas
                const pts = landmarks.map(lm => ({
                    x: lm.x * width,
                    y: lm.y * height
                }));
                // Draw lines
                for (const [a, b] of connections) {
                    if (pts[a] && pts[b]) {
                        ctx.beginPath();
                        ctx.moveTo(pts[a].x, pts[a].y);
                        ctx.lineTo(pts[b].x, pts[b].y);
                        ctx.stroke();
                    }
                }
                // Draw joints
                ctx.fillStyle = "#e94560";
                for (const pt of pts) {
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                }
                ctx.restore();
            }

            async start() {
                if (this.isRunning) {
                    document.getElementById('instructorStatus').textContent = 'Instructor is already running.';
                    return;
                }
                if (!Array.isArray(this.expectedLandmarks) || this.expectedLandmarks.length === 0) {
                    document.getElementById('instructorStatus').textContent = 'Load a move first.';
                    return;
                }
                this.isRunning = true;
                document.getElementById('instructorStatus').textContent = 'Starting instructor...';
                await this.startWebcam();
            }

            async startWebcam() {
                const video = document.getElementById('instructorVideo');
                const webcamCanvas = document.getElementById('instructorWebcam');
                const poseCanvas = document.getElementById('instructorPoseCanvas');
                // Always show video and canvas when running
                video.style.display = '';
                webcamCanvas.style.display = '';
                poseCanvas.style.display = '';
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    video.srcObject = stream;
                    await video.play();
                    // Set canvas sizes after video metadata is loaded
                    if (video.videoWidth === 0 || video.videoHeight === 0) {
                        await new Promise(resolve => {
                            video.onloadedmetadata = resolve;
                        });
                    }
                    webcamCanvas.width = video.videoWidth || 640;
                    webcamCanvas.height = video.videoHeight || 480;
                    poseCanvas.width = webcamCanvas.width;
                    poseCanvas.height = webcamCanvas.height;
                    this.similarityHistory = [];
                    this.feedbackDetails = null;
                    document.getElementById('instructorStatus').textContent = 'Instructor running. Webcam is active.';
                    this.runPoseDetection(video, webcamCanvas, poseCanvas);
                } catch (e) {
                    document.getElementById('instructorStatus').textContent = 'Webcam access denied or not available.';
                    video.style.display = 'none';
                    webcamCanvas.style.display = 'none';
                    poseCanvas.style.display = 'none';
                    this.isRunning = false;
                    console.error('Webcam error:', e);
                }
            }

            async runPoseDetection(video, webcamCanvas, poseCanvas) {
                if (!window.Pose) {
                    document.getElementById('instructorStatus').textContent = 'MediaPipe Pose not loaded.';
                    return;
                }
                const pose = new window.Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`
                });
                pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                pose.onResults(async (results) => {
                    const ctx = webcamCanvas.getContext('2d');
                    ctx.clearRect(0, 0, webcamCanvas.width, webcamCanvas.height);
                    ctx.drawImage(video, 0, 0, webcamCanvas.width, webcamCanvas.height);
                    if (results.poseLandmarks) {
                        // Extract keypoints and confidence scores
                        const keypoints = results.poseLandmarks.map((lm, idx) => ({
                            index: idx,
                            x: lm.x,
                            y: lm.y,
                            z: lm.z || 0,
                            confidence: lm.visibility
                        }));
                        // Compare with expectedLandmarks (fallback to zeros if missing)
                        let expected = this.expectedLandmarks;
                        if (!Array.isArray(expected) || expected.length !== keypoints.length) {
                            expected = Array.from({length: keypoints.length}, () => ({x: 0, y: 0, z: 0, visibility: 0}));
                        }
                        const liveLandmarks = keypoints.map(lm => ({
                            x: lm.x,
                            y: lm.y,
                            z: lm.z,
                            visibility: lm.confidence
                        }));
                        // Per-joint similarity (Euclidean distance)
                        let jointScores = [];
                        for (let i = 0; i < liveLandmarks.length; ++i) {
                            const l = liveLandmarks[i];
                            const e = expected[i];
                            if (l.visibility > 0.5 && e.visibility > 0.5) {
                                const dx = l.x - e.x;
                                const dy = l.y - e.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                // Assume max reasonable distance is 0.5 (normalized)
                                const sim = Math.max(0, 1 - dist / 0.5);
                                jointScores[i] = sim;
                            } else {
                                jointScores[i] = null;
                            }
                        }
                        // Color-coded skeleton overlay
                        const connections = [
                            [11, 13], [13, 15], [12, 14], [14, 16], // arms
                            [11, 12], // shoulders
                            [23, 24], // hips
                            [11, 23], [12, 24], // torso
                            [23, 25], [25, 27], [24, 26], [26, 28], // legs
                            [27, 31], [28, 32], // feet
                        ];
                        // Scale normalized landmarks to canvas
                        const pts = keypoints.map(lm => ({
                            x: lm.x * webcamCanvas.width,
                            y: lm.y * webcamCanvas.height,
                            confidence: lm.confidence
                        }));
                        for (const [a, b] of connections) {
                            if (pts[a] && pts[b]) {
                                // Color by minimum similarity of the two joints
                                let color = '#888';
                                if (jointScores[a] != null && jointScores[b] != null) {
                                    const minSim = Math.min(jointScores[a], jointScores[b]);
                                    if (minSim > 0.85) color = '#4caf50'; // green
                                    else if (minSim > 0.65) color = '#ffc107'; // yellow
                                    else color = '#e94560'; // red
                                }
                                ctx.save();
                                ctx.strokeStyle = color;
                                ctx.lineWidth = 5;
                                ctx.beginPath();
                                ctx.moveTo(pts[a].x, pts[a].y);
                                ctx.lineTo(pts[b].x, pts[b].y);
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                        // Draw joints as circles, color-coded
                        for (let i = 0; i < pts.length; ++i) {
                            let color = '#888';
                            if (jointScores[i] != null) {
                                if (jointScores[i] > 0.85) color = '#4caf50';
                                else if (jointScores[i] > 0.65) color = '#ffc107';
                                else color = '#e94560';
                            }
                            ctx.save();
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(pts[i].x, pts[i].y, 7, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }

                        // Overall similarity for feedback
                        const sim = window.compareLandmarks(
                            liveLandmarks,
                            expected
                        );
                        this.lastSimilarity = sim;
                        this.similarityHistory.push(sim);
                        if (this.similarityHistory.length > 30) this.similarityHistory.shift();
                        this.renderFeedbackChart();

                        // Enhanced: Call backend for detailed feedback every 1s
                        if (!this.feedbackTimer) {
                            this.feedbackTimer = setInterval(() => {
                                this.sendDetailedFeedback(liveLandmarks, expected);
                            }, 1000);
                        }

                        let msg = '';
                        if (sim > 0.85) msg = 'Great! Your pose matches the instructor!';
                        else if (sim > 0.65) msg = 'Good! Try to match the pose more closely.';
                        else msg = 'Keep practicing to match the instructor pose!';

                        // Show keypoints and confidence scores in feedback area
                        let kpTable = `<div style=\"margin-top:8px;font-size:0.95em;max-height:120px;overflow:auto;background:#181818;padding:6px 8px;border-radius:7px;\">
                            <b style='color:#f27121;'>Keypoints & Confidence</b><br>
                            <table style='width:100%;font-size:0.93em;color:#fff;'><tr><th>#</th><th>X</th><th>Y</th><th>Conf</th><th>Match</th></tr>`;
                        for (const kp of keypoints) {
                            let match = '';
                            if (jointScores[kp.index] != null) {
                                if (jointScores[kp.index] > 0.85) match = '<span style=\"color:#4caf50;\">‚úî</span>';
                                else if (jointScores[kp.index] > 0.65) match = '<span style=\"color:#ffc107;\">~</span>';
                                else match = '<span style=\"color:#e94560;\">‚úó</span>';
                            }
                            kpTable += `<tr><td>${kp.index}</td><td>${kp.x.toFixed(3)}</td><td>${kp.y.toFixed(3)}</td><td>${(kp.confidence*100).toFixed(1)}%</td><td>${match}</td></tr>`;
                        }
                        kpTable += `</table></div>`;

                        document.getElementById('instructorFeedback').innerHTML =
                            `<b>Similarity:</b> ${(sim*100).toFixed(1)}%<br>${msg}` + kpTable;
                    } else {
                        // No poseLandmarks detected
                        ctx.save();
                        ctx.fillStyle = '#e94560';
                        ctx.font = '22px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('No pose detected', webcamCanvas.width/2, webcamCanvas.height/2);
                        ctx.restore();
                    }
                });
                const camera = new window.Camera(video, {
                    onFrame: async () => {
                        await pose.send({ image: video });
                    },
                    width: webcamCanvas.width,
                    height: webcamCanvas.height
                });
                camera.start();
                this.poseInstance = pose;
                this.camera = camera;
            }

            async sendDetailedFeedback(userLandmarks, expectedLandmarks) {
                // Only send if both are valid and not all zeros
                if (!userLandmarks || !expectedLandmarks || userLandmarks.length !== expectedLandmarks.length) return;
                if (userLandmarks.every(lm => !lm.x && !lm.y && !lm.z)) return;
                try {
                    const res = await fetch(`${BACKEND_URL}/feedback`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            user_landmarks: userLandmarks,
                            expected_landmarks: expectedLandmarks
                        })
                    });
                    if (res.ok) {
                        const data = await res.json();
                        this.feedbackDetails = data;
                        this.renderDetailedFeedback();
                    }
                } catch {}
            }

            renderFeedbackChart() {
                // Add a simple sparkline chart for similarity history
                let chartId = "instructorFeedbackChart";
                let chartDiv = document.getElementById(chartId);
                if (!chartDiv) {
                    chartDiv = document.createElement("div");
                    chartDiv.id = chartId;
                    chartDiv.style.margin = "10px 0";
                    chartDiv.style.height = "40px";
                    chartDiv.style.width = "100%";
                    chartDiv.style.background = "#181818";
                    chartDiv.style.borderRadius = "8px";
                    chartDiv.style.display = "flex";
                    chartDiv.style.alignItems = "flex-end";
                    chartDiv.style.justifyContent = "center";
                    document.getElementById('instructorFeedback').appendChild(chartDiv);
                }
                chartDiv.innerHTML = "";
                const history = this.similarityHistory;
                if (!history || history.length === 0) {
                    chartDiv.innerHTML = "<span style='color:#aaa;font-size:0.9em;'>No feedback yet</span>";
                    return;
                }
                const max = 1, min = 0;
                const w = chartDiv.offsetWidth || 200;
                const h = chartDiv.offsetHeight || 40;
                const barW = Math.max(2, Math.floor(w / history.length));
                for (let i = 0; i < history.length; ++i) {
                    const val = history[i];
                    const bar = document.createElement("div");
                    bar.style.display = "inline-block";
                    bar.style.width = barW + "px";
                    bar.style.height = ((val - min) / (max - min) * h) + "px";
                    bar.style.marginRight = "1px";
                    bar.style.background = val > 0.85 ? "#4caf50" : val > 0.65 ? "#ffc107" : "#e94560";
                    bar.title = (val*100).toFixed(1) + "%";
                    chartDiv.appendChild(bar);
                }
            }

            renderDetailedFeedback() {
                // Show detailed feedback below the chart if available
                let detailsDiv = document.getElementById("instructorFeedbackDetails");
                if (!detailsDiv) {
                    detailsDiv = document.createElement("div");
                    detailsDiv.id = "instructorFeedbackDetails";
                    detailsDiv.style.margin = "8px 0 0 0";
                    detailsDiv.style.fontSize = "0.98em";
                    detailsDiv.style.color = "#fff";
                    document.getElementById('instructorFeedback').appendChild(detailsDiv);
                }
                if (!this.feedbackDetails || !this.feedbackDetails.details) {
                    detailsDiv.innerHTML = "";
                    return;
                }
                const { score, feedback, details } = this.feedbackDetails;
                let html = `<div style="color:#f27121;"><b>AI Feedback:</b> ${feedback} <span style="color:#aaa;">(Score: ${score})</span></div>`;
                if (details && details.joint_feedback && details.joint_feedback.length > 0) {
                    // Show top 2 joints needing improvement
                    const sorted = [...details.joint_feedback].sort((a, b) => b.distance - a.distance);
                    html += `<div style="margin-top:6px;">`;
                    for (let i = 0; i < Math.min(2, sorted.length); ++i) {
                        const j = sorted[i];
                        if (j.distance < 0.07) continue;
                        html += `<span style="color:#e94560;">${j.landmark}:</span> <span style="color:#ffc107;">${j.distance.toFixed(2)}</span> `;
                    }
                    html += `</div>`;
                }
                detailsDiv.innerHTML = html;
            }

            stop() {
                this.isRunning = false;
                if (this.camera && this.camera.stop) this.camera.stop();
                if (this.feedbackTimer) {
                    clearInterval(this.feedbackTimer);
                    this.feedbackTimer = null;
                }
                document.getElementById('instructorStatus').textContent = 'Instructor stopped.';
                document.getElementById('instructorFeedback').textContent = '';
                document.getElementById('instructorWebcam').style.display = 'none';
                document.getElementById('instructorPoseCanvas').style.display = 'none';
                this.similarityHistory = [];
                this.feedbackDetails = null;
                this.renderFeedbackChart();
                this.renderDetailedFeedback();
                this.updateSidebarInfo(0);
                document.getElementById('moveNameDisplay').textContent = '';
                document.getElementById('moveStyleDisplay').textContent = '';
            }

            // Enhanced Basic Instructor Methods
            initializeBasicInstructor() {
                this.basicSession = {
                    isActive: false,
                    startTime: null,
                    difficulty: 'beginner',
                    scores: [],
                    achievements: []
                };
                
                this.setupBasicEventListeners();
                this.updateBasicStats();
            }

            setupBasicEventListeners() {
                // Dance style dropdown change event
                const styleSelect = document.getElementById('instructorStyleSelect');
                if (styleSelect) {
                    styleSelect.addEventListener('change', () => {
                        this.populateEnhancedMotionDropdown();
                        this.clearStatus();
                    });
                }

                // Difficulty buttons
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => {
                            b.style.background = 'transparent';
                        });
                        btn.style.background = btn.style.borderColor;
                        this.basicSession.difficulty = btn.dataset.level;
                        this.updateDifficultyFeedback();
                    });
                });

                // Enhanced start button
                const startBtn = document.getElementById('instructorStartBtn');
                if (startBtn) {
                    startBtn.onclick = () => this.startBasicSession();
                }

                // Enhanced stop button
                const stopBtn = document.getElementById('instructorStopBtn');
                if (stopBtn) {
                    stopBtn.onclick = () => this.stopBasicSession();
                }

                // Pause button
                const pauseBtn = document.getElementById('instructorPauseBtn');
                if (pauseBtn) {
                    pauseBtn.onclick = () => this.pauseBasicSession();
                }
            }

            async setupBasicCamera() {
                try {
                    const constraints = {
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    };
                    
                    this.basicVideoStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    // Create a video element for processing
                    if (!this.basicVideoElement) {
                        this.basicVideoElement = document.createElement('video');
                        this.basicVideoElement.autoplay = true;
                        this.basicVideoElement.muted = true;
                        this.basicVideoElement.playsInline = true;
                        this.basicVideoElement.style.display = 'none';
                        document.body.appendChild(this.basicVideoElement);
                    }
                    
                    this.basicVideoElement.srcObject = this.basicVideoStream;
                    
                    // Setup canvas for webcam display
                    const webcamCanvas = document.getElementById('instructorWebcam');
                    const ctx = webcamCanvas.getContext('2d');
                    
                    // Wait for video to load
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            console.log('Video metadata timeout, using default dimensions');
                            // Fallback dimensions if metadata doesn't load
                            const containerWidth = webcamCanvas.offsetWidth || 640;
                            const containerHeight = 200;
                            webcamCanvas.width = containerWidth;
                            webcamCanvas.height = containerHeight;
                            this.videoWidth = 640;
                            this.videoHeight = 480;
                            resolve();
                        }, 3000);

                        this.basicVideoElement.onloadedmetadata = () => {
                            clearTimeout(timeout);
                            // Set canvas size to match container, not video dimensions
                            const containerWidth = webcamCanvas.offsetWidth || 640;
                            const containerHeight = 200; // Fixed height as per CSS
                            webcamCanvas.width = containerWidth;
                            webcamCanvas.height = containerHeight;
                            
                            // Store video dimensions for proper scaling
                            this.videoWidth = this.basicVideoElement.videoWidth;
                            this.videoHeight = this.basicVideoElement.videoHeight;
                            
                            resolve();
                        };
                    });
                    
                    // Show webcam canvas and hide placeholder if any
                    webcamCanvas.style.display = 'block';
                    
                    // Debug info
                    console.log('Camera setup complete:', {
                        canvas: webcamCanvas,
                        canvasWidth: webcamCanvas.width,
                        canvasHeight: webcamCanvas.height,
                        videoWidth: this.videoWidth,
                        videoHeight: this.videoHeight,
                        display: webcamCanvas.style.display
                    });
                    
                    // Start drawing video frames to canvas
                    this.startBasicVideoLoop(ctx, webcamCanvas);
                    
                    this.updateBasicStatus('Camera connected! Ready to track your moves.', 'success');
                    
                    return true;
                } catch (error) {
                    console.error('Basic camera setup failed:', error);
                    this.updateBasicStatus('Camera access denied. Please enable camera for pose tracking.', 'error');
                    return false;
                }
            }

            startBasicVideoLoop(ctx, canvas) {
                const drawFrame = () => {
                    if (this.basicVideoElement && this.basicVideoStream) {
                        try {
                            // Clear canvas
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Check if video is ready
                            if (this.basicVideoElement.readyState >= 2) {
                                // Calculate aspect ratio scaling
                                const videoAspect = this.videoWidth / this.videoHeight;
                                const canvasAspect = canvas.width / canvas.height;
                                
                                let drawWidth, drawHeight, offsetX, offsetY;
                                
                                if (videoAspect > canvasAspect) {
                                    // Video is wider - fit to width
                                    drawWidth = canvas.width;
                                    drawHeight = canvas.width / videoAspect;
                                    offsetX = 0;
                                    offsetY = (canvas.height - drawHeight) / 2;
                                } else {
                                    // Video is taller - fit to height
                                    drawHeight = canvas.height;
                                    drawWidth = canvas.height * videoAspect;
                                    offsetX = (canvas.width - drawWidth) / 2;
                                    offsetY = 0;
                                }
                                
                                // Draw video frame with proper scaling
                                ctx.drawImage(this.basicVideoElement, offsetX, offsetY, drawWidth, drawHeight);
                                
                                // Add pose tracking overlay here if needed
                                this.drawBasicPoseOverlay(ctx, canvas);
                            } else {
                                // Video not ready, show loading indicator
                                ctx.fillStyle = 'rgba(102, 126, 234, 0.8)';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = 'white';
                                ctx.font = '18px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('Loading camera...', canvas.width / 2, canvas.height / 2);
                                ctx.textAlign = 'left';
                            }
                        } catch (error) {
                            console.error('Error drawing video frame:', error);
                            // Show error on canvas
                            ctx.fillStyle = 'rgba(245, 87, 108, 0.8)';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = 'white';
                            ctx.font = '16px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('Camera Error', canvas.width / 2, canvas.height / 2);
                            ctx.textAlign = 'left';
                        }
                    }
                    
                    // Continue animation loop
                    requestAnimationFrame(drawFrame);
                };
                
                // Start the drawing loop
                drawFrame();
            }

            drawBasicPoseOverlay(ctx, canvas) {
                // Simple pose tracking visualization
                if (this.basicSession.isActive) {
                    ctx.strokeStyle = '#f27121';
                    ctx.lineWidth = 3;
                    ctx.font = '16px Arial';
                    ctx.fillStyle = '#f27121';
                    
                    // Add some basic pose indicators (simulated)
                    const time = Date.now() / 1000;
                    const x = (Math.sin(time) * 50) + canvas.width / 2;
                    const y = (Math.cos(time) * 30) + canvas.height / 2;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    // Add tracking indicator
                    ctx.fillText('Tracking...', 10, 30);
                }
            }

            async startBasicSession() {
                const selectedStyle = document.getElementById('instructorStyleSelect').value;
                const selectedMove = document.getElementById('instructorMoveSelect').value;
                
                if (!selectedStyle || !selectedMove) {
                    this.updateBasicStatus('Please select both dance style and move to start', 'warning');
                    return;
                }

                // Setup camera first
                this.updateBasicStatus('Setting up camera...', 'info');
                
                // Show the webcam canvas immediately
                const webcamCanvas = document.getElementById('instructorWebcam');
                webcamCanvas.style.display = 'block';
                
                const cameraSuccess = await this.setupBasicCamera();
                
                if (!cameraSuccess) {
                    // Even if camera fails, show a placeholder
                    const ctx = webcamCanvas.getContext('2d');
                    webcamCanvas.width = webcamCanvas.offsetWidth || 640;
                    webcamCanvas.height = 200;
                    
                    ctx.fillStyle = 'rgba(102, 126, 234, 0.8)';
                    ctx.fillRect(0, 0, webcamCanvas.width, webcamCanvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Camera not available', webcamCanvas.width / 2, webcamCanvas.height / 2);
                    ctx.textAlign = 'left';
                    
                    this.updateBasicStatus('Session started without camera', 'warning');
                } else {
                    this.updateBasicStatus('Camera connected successfully!', 'success');
                }

                this.basicSession.isActive = true;
                this.basicSession.startTime = Date.now();
                
                // Update UI
                document.getElementById('instructorStartBtn').style.display = 'none';
                document.getElementById('instructorPauseBtn').style.display = 'inline-block';
                document.getElementById('instructorStopBtn').innerHTML = '‚èπÔ∏è Stop Session';
                
                // Show overlay instructions
                document.getElementById('instructorOverlay').style.display = 'block';
                document.getElementById('currentMoveDisplay').textContent = `${selectedStyle.toUpperCase()}: ${selectedMove}`;
                document.getElementById('moveInstructions').textContent = this.getBasicInstructions();
                
                // Show performance indicator
                document.getElementById('performanceIndicator').style.display = 'block';
                
                // Start pose detection and feedback
                this.startBasicPoseTracking();
                
                this.updateBasicStatus(`Session started! Difficulty: ${this.basicSession.difficulty}`, 'success');
                this.updateBasicProgress();
            }

            pauseBasicSession() {
                const pauseBtn = document.getElementById('instructorPauseBtn');
                
                if (this.basicSession.isActive) {
                    this.basicSession.isActive = false;
                    pauseBtn.innerHTML = '‚ñ∂Ô∏è Resume';
                    this.updateBasicStatus('Session paused', 'info');
                } else {
                    this.basicSession.isActive = true;
                    pauseBtn.innerHTML = '‚è∏Ô∏è Pause';
                    this.updateBasicStatus('Session resumed', 'success');
                    this.startBasicPoseTracking();
                }
            }

            stopBasicSession() {
                this.basicSession.isActive = false;
                
                // Reset UI
                document.getElementById('instructorStartBtn').style.display = 'inline-block';
                document.getElementById('instructorPauseBtn').style.display = 'none';
                document.getElementById('instructorStopBtn').innerHTML = '‚èπÔ∏è Stop';
                
                // Hide overlays
                document.getElementById('instructorOverlay').style.display = 'none';
                document.getElementById('performanceIndicator').style.display = 'none';
                
                // Reset progress
                document.getElementById('sessionProgress').style.width = '0%';
                document.getElementById('progressPercent').textContent = '0%';
                document.getElementById('sessionTime').textContent = '00:00';
                
                // Stop pose tracking
                if (this.basicTrackingInterval) {
                    clearInterval(this.basicTrackingInterval);
                }
                
                // Calculate session stats
                if (this.basicSession.startTime) {
                    const sessionDuration = Math.floor((Date.now() - this.basicSession.startTime) / 1000);
                    const avgScore = this.basicSession.scores.length > 0 
                        ? Math.floor(this.basicSession.scores.reduce((a, b) => a + b, 0) / this.basicSession.scores.length)
                        : 0;
                    
                    this.checkBasicAchievements(sessionDuration, avgScore);
                }
                
                this.updateBasicStatus('Session completed! Great work!', 'success');
                this.basicSession = { isActive: false, startTime: null, difficulty: 'beginner', scores: [], achievements: [] };
            }

            startBasicPoseTracking() {
                if (this.basicTrackingInterval) {
                    clearInterval(this.basicTrackingInterval);
                }
                
                this.basicTrackingInterval = setInterval(() => {
                    if (this.basicSession.isActive) {
                        this.simulateBasicPoseAnalysis();
                        this.updateSessionTimer();
                    }
                }, 1000);
            }

            simulateBasicPoseAnalysis() {
                // Simulate pose analysis based on difficulty
                const difficultyMultiplier = {
                    'beginner': 0.9,
                    'intermediate': 0.75,
                    'advanced': 0.6
                };
                
                const baseScore = Math.random() * 100;
                const adjustedScore = Math.floor(baseScore * difficultyMultiplier[this.basicSession.difficulty]);
                const accuracy = Math.max(60, adjustedScore);
                const timing = Math.max(50, Math.floor(Math.random() * 100));
                
                // Update live stats
                document.getElementById('basicAccuracy').textContent = accuracy + '%';
                document.getElementById('basicTiming').textContent = timing + '%';
                document.getElementById('performanceScore').textContent = Math.floor((accuracy + timing) / 2);
                
                // Store score
                this.basicSession.scores.push(accuracy);
                
                // Update recent scores display
                this.updateRecentScores(accuracy);
                
                // Update feedback
                this.updateBasicFeedback(accuracy, timing);
            }

            updateRecentScores(score) {
                const recentScoresContainer = document.getElementById('recentScores');
                const scoreElement = document.createElement('span');
                
                const scoreClass = score >= 80 ? '#4CAF50' : score >= 60 ? '#FF9800' : '#F44336';
                scoreElement.style.cssText = `
                    background: rgba(${score >= 80 ? '76,175,80' : score >= 60 ? '255,152,0' : '244,67,54'},0.2);
                    color: ${scoreClass};
                    padding: 4px 8px;
                    border-radius: 12px;
                    font-size: 0.8rem;
                    animation: scoreSlideIn 0.3s ease-out;
                `;
                scoreElement.textContent = score + '%';
                
                recentScoresContainer.appendChild(scoreElement);
                
                // Keep only last 5 scores
                while (recentScoresContainer.children.length > 5) {
                    recentScoresContainer.removeChild(recentScoresContainer.firstChild);
                }
            }

            updateBasicFeedback(accuracy, timing) {
                const feedbackDiv = document.getElementById('instructorFeedback');
                let emoji, message, color;
                
                const avgScore = Math.floor((accuracy + timing) / 2);
                
                if (avgScore >= 85) {
                    emoji = 'üåü';
                    message = 'Excellent! You\'re mastering this move!';
                    color = '#4CAF50';
                } else if (avgScore >= 70) {
                    emoji = 'üëç';
                    message = 'Great job! Keep up the good work!';
                    color = '#667eea';
                } else if (avgScore >= 55) {
                    emoji = 'üìà';
                    message = 'Good progress! Focus on timing and posture.';
                    color = '#FF9800';
                } else {
                    emoji = 'üí™';
                    message = 'Keep practicing! Watch the reference closely.';
                    color = '#F44336';
                }
                
                feedbackDiv.innerHTML = `
                    <div style="color:${color}; font-size: 1.1rem; font-weight: bold; margin-bottom: 8px;">
                        ${emoji} ${message}
                    </div>
                    <div style="color: rgba(255,255,255,0.8); font-size: 0.9rem;">
                        Accuracy: ${accuracy}% | Timing: ${timing}%
                    </div>
                `;
            }

            updateSessionTimer() {
                if (this.basicSession.startTime) {
                    const elapsed = Math.floor((Date.now() - this.basicSession.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('sessionTime').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    // Update progress (simulate 5 minute session)
                    const progress = Math.min(100, (elapsed / 300) * 100);
                    document.getElementById('sessionProgress').style.width = progress + '%';
                    document.getElementById('progressPercent').textContent = Math.floor(progress) + '%';
                }
            }

            checkBasicAchievements(duration, avgScore) {
                const achievements = [];
                
                if (!this.basicSession.achievements.includes('firstSession')) {
                    achievements.push({ id: 'firstSession', title: 'First Session', desc: 'Completed your first dance session!' });
                    this.basicSession.achievements.push('firstSession');
                }
                
                if (avgScore >= 80 && !this.basicSession.achievements.includes('scoremaster')) {
                    achievements.push({ id: 'scoremaster', title: 'Score Master', desc: 'Achieved 80% average score!' });
                    this.basicSession.achievements.push('scoremaster');
                }
                
                if (duration >= 180 && !this.basicSession.achievements.includes('endurance')) {
                    achievements.push({ id: 'endurance', title: 'Endurance Dancer', desc: 'Practiced for 3+ minutes!' });
                    this.basicSession.achievements.push('endurance');
                }
                
                // Show achievement notifications
                achievements.forEach((achievement, index) => {
                    setTimeout(() => this.showBasicAchievement(achievement), index * 2000);
                });
            }

            showBasicAchievement(achievement) {
                const achievementDiv = document.createElement('div');
                achievementDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 12px;
                    z-index: 1000;
                    animation: slideInRight 0.5s ease-out;
                    max-width: 300px;
                `;
                
                achievementDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 5px;">üèÜ Achievement Unlocked!</div>
                    <div style="font-size: 1.1rem; margin-bottom: 3px;">${achievement.title}</div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">${achievement.desc}</div>
                `;
                
                document.body.appendChild(achievementDiv);
                
                setTimeout(() => {
                    achievementDiv.style.animation = 'slideOutRight 0.5s ease-in';
                    setTimeout(() => document.body.removeChild(achievementDiv), 500);
                }, 3000);
            }

            updateBasicStatus(message, type = 'info') {
                const statusDiv = document.getElementById('instructorStatus');
                const colors = {
                    'info': '#667eea',
                    'success': '#4CAF50',
                    'warning': '#FF9800',
                    'error': '#F44336'
                };
                
                statusDiv.style.color = colors[type];
                statusDiv.textContent = message;
            }

            updateDifficultyFeedback() {
                const tips = {
                    'beginner': 'Focus on basic posture and slow, controlled movements',
                    'intermediate': 'Add expression and improve timing precision',
                    'advanced': 'Perfect technique with fluid transitions and style'
                };
                
                document.getElementById('moveInstructions').textContent = tips[this.basicSession.difficulty];
            }

            getBasicInstructions() {
                const instructions = {
                    'bollywood': 'Express emotion through graceful arm movements and hip sways',
                    'kathak': 'Maintain straight posture with precise hand positions and spins',
                    'hiphop': 'Use sharp, rhythmic movements with attitude and style',
                    'contemporary': 'Flow smoothly between positions with emotional expression'
                };
                
                const style = document.getElementById('instructorStyleSelect').value;
                return instructions[style] || 'Follow the reference movements closely';
            }

            clearStatus() {
                this.updateBasicStatus('Ready to start your dance session', 'info');
            }

            updateBasicStats() {
                // Update session count
                const sessionCount = localStorage.getItem('basicInstructorSessions') || '0';
                document.getElementById('sessionCount').textContent = sessionCount;
                
                // Update average score
                const avgScore = localStorage.getItem('basicInstructorAvgScore') || '75';
                document.getElementById('avgScore').textContent = avgScore;
                
                // Update total time
                const totalTime = localStorage.getItem('basicInstructorTotalTime') || '0.0';
                document.getElementById('totalTime').textContent = totalTime;
            }
        }

        // Add CSS for animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                0% { transform: translateX(100%); opacity: 0; }
                100% { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                0% { transform: translateX(0); opacity: 1; }
                100% { transform: translateX(100%); opacity: 0; }
            }
            @keyframes scoreSlideIn {
                0% { transform: scale(0) translateY(-10px); opacity: 0; }
                100% { transform: scale(1) translateY(0); opacity: 1; }
            }
        `;
        document.head.appendChild(style);

        // Function to toggle basic instructor visibility
        function openBasicInstructor() {
            const heroSection = document.querySelector('#instructor .hero');
            const basicInstructor = document.getElementById('basicInstructor');
            
            if (basicInstructor.style.display === 'none' || basicInstructor.style.display === '') {
                heroSection.style.display = 'none';
                basicInstructor.style.display = 'block';
                
                // Initialize enhanced basic instructor features
                if (window.virtualInstructor && window.virtualInstructor.initializeBasicInstructor) {
                    window.virtualInstructor.initializeBasicInstructor();
                }
            } else {
                heroSection.style.display = 'block';
                basicInstructor.style.display = 'none';
            }
        }

        // Initialize Application
        document.addEventListener('DOMContentLoaded', () => {
            window.router = new Router();
            window.liveTracker = new LiveTracker();
            window.choreoGenerator = new ChoreographyGenerator();
            window.galleryManager = new GalleryManager();
            window.virtualInstructor = new VirtualDanceInstructor();

            // About page navigation support
            document.querySelectorAll('[data-page="about"]').forEach(el => {
                el.addEventListener('click', e => {
                    e.preventDefault();
                    window.router.navigateTo('about');
                    loadAboutPage();
                });
            });

            // Virtual Dance Instructor navigation support
            document.querySelectorAll('[data-page="instructor"]').forEach(el => {
                el.addEventListener('click', e => {
                    e.preventDefault();
                    window.router.navigateTo('instructor');
                    // Reset to hero view when navigating to instructor page
                    const heroSection = document.querySelector('#instructor .hero');
                    const basicInstructor = document.getElementById('basicInstructor');
                    if (heroSection && basicInstructor) {
                        heroSection.style.display = 'block';
                        basicInstructor.style.display = 'none';
                    }
                });
            });

            // Make logo clickable to go to home
            document.getElementById('navHome').addEventListener('click', e => {
                e.preventDefault();
                window.router.navigateTo('home');
            });

            // Load about page if navigated directly
            if (window.location.hash === "#about" || window.router.currentPage === "about") {
                window.router.navigateTo('about');
                loadAboutPage();
            }
        });
    </script>
</body>
</html>